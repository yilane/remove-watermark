# ä»»åŠ¡07: è’™ç‰ˆç»˜åˆ¶å·¥å…·å¼€å‘

## ä»»åŠ¡æ¦‚è¿°

å¼€å‘å›¾åƒè’™ç‰ˆç»˜åˆ¶å·¥å…·ï¼Œç”¨æˆ·å¯ä»¥åœ¨å›¾ç‰‡ä¸Šæ ‡è®°éœ€è¦ä¿®å¤çš„åŒºåŸŸï¼Œæ”¯æŒç”»ç¬”ã€æ©¡çš®æ“¦ã€æ™ºèƒ½é€‰æ‹©ç­‰åŠŸèƒ½ã€‚

## æŠ€æœ¯è¦æ±‚

### å°ç¨‹åºç«¯æŠ€æœ¯
- **Canvas 2D**: ç»˜åˆ¶åŠŸèƒ½å®ç°
- **è§¦æ‘¸äº‹ä»¶**: æ‰‹åŠ¿æ“ä½œå¤„ç†
- **å›¾åƒå¤„ç†**: è’™ç‰ˆæ•°æ®ç”Ÿæˆ
- **æ–‡ä»¶ç³»ç»Ÿ**: ä¸´æ—¶æ–‡ä»¶ç®¡ç†

## å®ç°æ­¥éª¤

### æ­¥éª¤1: Canvasç»˜åˆ¶ç»„ä»¶

#### 1.1 è’™ç‰ˆç¼–è¾‘å™¨ç»„ä»¶
```xml
<!-- components/mask-editor/index.wxml -->
<view class="mask-editor">
  <!-- å·¥å…·æ  -->
  <view class="toolbar">
    <button 
      class="tool-btn {{currentTool === 'brush' ? 'active' : ''}}"
      size="mini"
      bindtap="setTool"
      data-tool="brush"
    >
      ç”»ç¬”
    </button>
    <button 
      class="tool-btn {{currentTool === 'eraser' ? 'active' : ''}}"
      size="mini" 
      bindtap="setTool"
      data-tool="eraser"
    >
      æ©¡çš®æ“¦
    </button>
    <button class="tool-btn" size="mini" bindtap="clearMask">æ¸…é™¤</button>
    <button class="tool-btn" size="mini" bindtap="undoLastStroke">æ’¤é”€</button>
  </view>

  <!-- ç”»ç¬”å¤§å°è°ƒèŠ‚ -->
  <view class="brush-size">
    <text>ç”»ç¬”å¤§å°ï¼š{{brushSize}}</text>
    <slider 
      value="{{brushSize}}" 
      min="5" 
      max="50" 
      step="1"
      show-value
      bindchange="onBrushSizeChange"
    />
  </view>

  <!-- ç”»å¸ƒå®¹å™¨ -->
  <view class="canvas-container">
    <canvas 
      canvas-id="imageCanvas"
      type="2d"
      class="image-canvas"
      disable-scroll="true"
      bindtouchstart="onTouchStart"
      bindtouchmove="onTouchMove" 
      bindtouchend="onTouchEnd"
    />
    <canvas 
      canvas-id="maskCanvas"
      type="2d"
      class="mask-canvas"
      disable-scroll="true"
      bindtouchstart="onTouchStart"
      bindtouchmove="onTouchMove"
      bindtouchend="onTouchEnd"
    />
  </view>

  <!-- æ“ä½œæŒ‰é’® -->
  <view class="actions">
    <button bindtap="previewMask">é¢„è§ˆè’™ç‰ˆ</button>
    <button type="primary" bindtap="confirmMask">ç¡®è®¤</button>
  </view>
</view>
```

```javascript
// components/mask-editor/index.js
Component({
  properties: {
    imageUrl: {
      type: String,
      value: ''
    }
  },

  data: {
    currentTool: 'brush',
    brushSize: 20,
    isDrawing: false,
    strokes: [],
    canvasWidth: 0,
    canvasHeight: 0,
    imageWidth: 0,
    imageHeight: 0,
    imageOffsetX: 0,
    imageOffsetY: 0,
    scale: 1
  },

  lifetimes: {
    attached() {
      this.initCanvas()
    }
  },

  methods: {
    // åˆå§‹åŒ–ç”»å¸ƒ
    async initCanvas() {
      try {
        // è·å–ç³»ç»Ÿä¿¡æ¯
        const systemInfo = await this.getSystemInfo()
        const canvasWidth = systemInfo.windowWidth - 40
        const canvasHeight = (systemInfo.windowWidth - 40) * 0.75
        
        this.setData({
          canvasWidth,
          canvasHeight
        })

        // åˆå§‹åŒ–Canvas 2Dä¸Šä¸‹æ–‡
        await this.initCanvasContext()
        
        // åŠ è½½å›¾ç‰‡
        if (this.properties.imageUrl) {
          await this.loadImage()
        }
      } catch (error) {
        console.error('åˆå§‹åŒ–ç”»å¸ƒå¤±è´¥:', error)
        wx.showToast({
          title: 'åˆå§‹åŒ–å¤±è´¥',
          icon: 'none'
        })
      }
    },

    // è·å–ç³»ç»Ÿä¿¡æ¯
    getSystemInfo() {
      return new Promise((resolve) => {
        wx.getSystemInfo({
          success: resolve
        })
      })
    },

    // åˆå§‹åŒ–Canvas 2Dä¸Šä¸‹æ–‡
    async initCanvasContext() {
      // è·å–å›¾åƒç”»å¸ƒä¸Šä¸‹æ–‡
      this.imageCanvas = await new Promise((resolve) => {
        wx.createSelectorQuery()
          .in(this)
          .select('#imageCanvas')
          .fields({ node: true, size: true })
          .exec((res) => {
            const canvas = res[0].node
            const ctx = canvas.getContext('2d')
            
            // è®¾ç½®ç”»å¸ƒå°ºå¯¸
            const dpr = wx.getSystemInfoSync().pixelRatio
            canvas.width = this.data.canvasWidth * dpr
            canvas.height = this.data.canvasHeight * dpr
            ctx.scale(dpr, dpr)
            
            resolve({ canvas, ctx })
          })
      })

      // è·å–è’™ç‰ˆç”»å¸ƒä¸Šä¸‹æ–‡
      this.maskCanvas = await new Promise((resolve) => {
        wx.createSelectorQuery()
          .in(this)
          .select('#maskCanvas')
          .fields({ node: true, size: true })
          .exec((res) => {
            const canvas = res[0].node
            const ctx = canvas.getContext('2d')
            
            // è®¾ç½®ç”»å¸ƒå°ºå¯¸
            const dpr = wx.getSystemInfoSync().pixelRatio
            canvas.width = this.data.canvasWidth * dpr
            canvas.height = this.data.canvasHeight * dpr
            ctx.scale(dpr, dpr)
            
            resolve({ canvas, ctx })
          })
      })

      // è®¾ç½®è’™ç‰ˆç”»å¸ƒæ ·å¼
      this.setupMaskCanvas()
    },

    // åŠ è½½å›¾ç‰‡åˆ°ç”»å¸ƒ
    async loadImage() {
      try {
        const imageInfo = await this.getImageInfo(this.properties.imageUrl)
        
        // è®¡ç®—å›¾ç‰‡æ˜¾ç¤ºå°ºå¯¸å’Œä½ç½®
        const { width, height, offsetX, offsetY, scale } = this.calculateImageLayout(
          imageInfo.width, 
          imageInfo.height
        )
        
        this.setData({
          imageWidth: width,
          imageHeight: height,
          imageOffsetX: offsetX,
          imageOffsetY: offsetY,
          scale
        })

        // åˆ›å»ºå›¾ç‰‡å¯¹è±¡
        const img = this.imageCanvas.canvas.createImage()
        img.onload = () => {
          // æ¸…é™¤ç”»å¸ƒ
          this.imageCanvas.ctx.clearRect(0, 0, this.data.canvasWidth, this.data.canvasHeight)
          
          // ç»˜åˆ¶å›¾ç‰‡
          this.imageCanvas.ctx.drawImage(img, offsetX, offsetY, width, height)
        }
        img.src = this.properties.imageUrl
        
      } catch (error) {
        console.error('åŠ è½½å›¾ç‰‡å¤±è´¥:', error)
        wx.showToast({
          title: 'åŠ è½½å›¾ç‰‡å¤±è´¥',
          icon: 'none'
        })
      }
    },

    // è·å–å›¾ç‰‡ä¿¡æ¯
    getImageInfo(src) {
      return new Promise((resolve, reject) => {
        wx.getImageInfo({
          src,
          success: resolve,
          fail: reject
        })
      })
    },

    // è®¡ç®—å›¾ç‰‡å¸ƒå±€
    calculateImageLayout(originalWidth, originalHeight) {
      const maxWidth = this.data.canvasWidth
      const maxHeight = this.data.canvasHeight
      
      const ratio = Math.min(maxWidth / originalWidth, maxHeight / originalHeight)
      
      const width = originalWidth * ratio
      const height = originalHeight * ratio
      const offsetX = (maxWidth - width) / 2
      const offsetY = (maxHeight - height) / 2
      
      return { width, height, offsetX, offsetY, scale: ratio }
    },

    // è®¾ç½®è’™ç‰ˆç”»å¸ƒ
    setupMaskCanvas() {
      const ctx = this.maskCanvas.ctx
      ctx.globalAlpha = 0.5
      ctx.lineCap = 'round'
      ctx.lineJoin = 'round'
      ctx.strokeStyle = '#ff0000'
    },

    // è®¾ç½®å·¥å…·
    setTool(e) {
      const tool = e.currentTarget.dataset.tool
      this.setData({
        currentTool: tool
      })
      
      // æ›´æ–°ç”»ç¬”æ ·å¼
      const ctx = this.maskCanvas.ctx
      if (tool === 'brush') {
        ctx.globalCompositeOperation = 'source-over'
        ctx.strokeStyle = '#ff0000'
      } else if (tool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out'
      }
    },

    // ç”»ç¬”å¤§å°æ”¹å˜
    onBrushSizeChange(e) {
      const brushSize = e.detail.value
      this.setData({ brushSize })
      
      // æ›´æ–°ç”»ç¬”å¤§å°
      this.maskCanvas.ctx.lineWidth = brushSize
    },

    // è§¦æ‘¸å¼€å§‹
    onTouchStart(e) {
      const touch = e.touches[0]
      const { x, y } = this.getCanvasPosition(touch)
      
      // æ£€æŸ¥æ˜¯å¦åœ¨å›¾ç‰‡åŒºåŸŸå†…
      if (!this.isPointInImage(x, y)) {
        return
      }
      
      this.setData({ isDrawing: true })
      this.startNewStroke(x, y)
    },

    // è§¦æ‘¸ç§»åŠ¨
    onTouchMove(e) {
      if (!this.data.isDrawing) return
      
      const touch = e.touches[0]
      const { x, y } = this.getCanvasPosition(touch)
      
      // æ£€æŸ¥æ˜¯å¦åœ¨å›¾ç‰‡åŒºåŸŸå†…
      if (!this.isPointInImage(x, y)) {
        return
      }
      
      this.continueStroke(x, y)
    },

    // è§¦æ‘¸ç»“æŸ
    onTouchEnd() {
      if (this.data.isDrawing) {
        this.finishStroke()
        this.setData({ isDrawing: false })
      }
    },

    // è·å–ç”»å¸ƒåæ ‡
    getCanvasPosition(touch) {
      return new Promise((resolve) => {
        wx.createSelectorQuery()
          .in(this)
          .select('.canvas-container')
          .boundingClientRect((rect) => {
            const x = touch.clientX - rect.left
            const y = touch.clientY - rect.top
            resolve({ x, y })
          })
          .exec()
      })
    },

    // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨å›¾ç‰‡åŒºåŸŸå†…
    isPointInImage(x, y) {
      const { imageOffsetX, imageOffsetY, imageWidth, imageHeight } = this.data
      return x >= imageOffsetX && 
             x <= imageOffsetX + imageWidth && 
             y >= imageOffsetY && 
             y <= imageOffsetY + imageHeight
    },

    // å¼€å§‹æ–°çš„ç¬”ç”»
    startNewStroke(x, y) {
      const ctx = this.maskCanvas.ctx
      
      // å¼€å§‹æ–°è·¯å¾„
      ctx.beginPath()
      ctx.moveTo(x, y)
      
      // è®°å½•ç¬”ç”»èµ·ç‚¹
      const stroke = {
        tool: this.data.currentTool,
        size: this.data.brushSize,
        points: [{ x, y }]
      }
      
      this.currentStroke = stroke
    },

    // ç»§ç»­ç¬”ç”»
    continueStroke(x, y) {
      const ctx = this.maskCanvas.ctx
      
      // ç»˜åˆ¶åˆ°å½“å‰ç‚¹
      ctx.lineTo(x, y)
      ctx.stroke()
      
      // è®°å½•ç‚¹
      if (this.currentStroke) {
        this.currentStroke.points.push({ x, y })
      }
    },

    // å®Œæˆç¬”ç”»
    finishStroke() {
      if (this.currentStroke) {
        // ä¿å­˜ç¬”ç”»åˆ°å†å²è®°å½•
        const strokes = [...this.data.strokes, this.currentStroke]
        this.setData({ strokes })
        this.currentStroke = null
      }
    },

    // æ¸…é™¤è’™ç‰ˆ
    clearMask() {
      const ctx = this.maskCanvas.ctx
      ctx.clearRect(0, 0, this.data.canvasWidth, this.data.canvasHeight)
      this.setData({ strokes: [] })
    },

    // æ’¤é”€æœ€åä¸€ç¬”
    undoLastStroke() {
      const strokes = [...this.data.strokes]
      if (strokes.length > 0) {
        strokes.pop()
        this.setData({ strokes })
        this.redrawMask()
      }
    },

    // é‡ç»˜è’™ç‰ˆ
    redrawMask() {
      const ctx = this.maskCanvas.ctx
      
      // æ¸…é™¤ç”»å¸ƒ
      ctx.clearRect(0, 0, this.data.canvasWidth, this.data.canvasHeight)
      
      // é‡ç»˜æ‰€æœ‰ç¬”ç”»
      this.data.strokes.forEach(stroke => {
        this.drawStroke(stroke)
      })
    },

    // ç»˜åˆ¶å•ä¸ªç¬”ç”»
    drawStroke(stroke) {
      const ctx = this.maskCanvas.ctx
      
      // è®¾ç½®æ ·å¼
      ctx.lineWidth = stroke.size
      if (stroke.tool === 'brush') {
        ctx.globalCompositeOperation = 'source-over'
        ctx.strokeStyle = '#ff0000'
      } else if (stroke.tool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out'
      }
      
      // ç»˜åˆ¶è·¯å¾„
      ctx.beginPath()
      stroke.points.forEach((point, index) => {
        if (index === 0) {
          ctx.moveTo(point.x, point.y)
        } else {
          ctx.lineTo(point.x, point.y)
        }
      })
      ctx.stroke()
    },

    // é¢„è§ˆè’™ç‰ˆ
    previewMask() {
      // åˆ‡æ¢è’™ç‰ˆæ˜¾ç¤ºæ¨¡å¼
      const ctx = this.maskCanvas.ctx
      const currentAlpha = ctx.globalAlpha
      ctx.globalAlpha = currentAlpha === 0.5 ? 0.8 : 0.5
    },

    // ç¡®è®¤è’™ç‰ˆ
    async confirmMask() {
      try {
        wx.showLoading({
          title: 'ç”Ÿæˆè’™ç‰ˆä¸­...'
        })

        // ç”Ÿæˆè’™ç‰ˆæ•°æ®
        const maskData = await this.generateMaskData()
        
        wx.hideLoading()
        
        // è§¦å‘ç¡®è®¤äº‹ä»¶
        this.triggerEvent('mask-confirm', {
          maskData,
          imageInfo: {
            width: this.data.imageWidth,
            height: this.data.imageHeight,
            offsetX: this.data.imageOffsetX,
            offsetY: this.data.imageOffsetY,
            scale: this.data.scale
          }
        })
        
      } catch (error) {
        wx.hideLoading()
        console.error('ç”Ÿæˆè’™ç‰ˆå¤±è´¥:', error)
        wx.showToast({
          title: 'ç”Ÿæˆè’™ç‰ˆå¤±è´¥',
          icon: 'none'
        })
      }
    },

    // ç”Ÿæˆè’™ç‰ˆæ•°æ®
    async generateMaskData() {
      return new Promise((resolve, reject) => {
        // å°†è’™ç‰ˆç”»å¸ƒå¯¼å‡ºä¸ºä¸´æ—¶æ–‡ä»¶
        wx.canvasToTempFilePath({
          canvasId: 'maskCanvas',
          success: (res) => {
            resolve({
              maskImagePath: res.tempFilePath,
              strokes: this.data.strokes
            })
          },
          fail: reject
        }, this)
      })
    }
  }
})
```

```css
/* components/mask-editor/index.wxss */
.mask-editor {
  padding: 20rpx;
}

.toolbar {
  display: flex;
  justify-content: space-around;
  margin-bottom: 20rpx;
  padding: 20rpx;
  background: #f5f5f5;
  border-radius: 12rpx;
}

.tool-btn {
  font-size: 24rpx;
  margin: 0 10rpx;
}

.tool-btn.active {
  background: #1aad19;
  color: white;
}

.brush-size {
  margin-bottom: 20rpx;
  padding: 20rpx;
  background: #f9f9f9;
  border-radius: 12rpx;
}

.brush-size text {
  font-size: 28rpx;
  color: #333;
  margin-bottom: 20rpx;
  display: block;
}

.canvas-container {
  position: relative;
  margin-bottom: 30rpx;
  border: 2rpx solid #ddd;
  border-radius: 12rpx;
  overflow: hidden;
}

.image-canvas,
.mask-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.image-canvas {
  z-index: 1;
}

.mask-canvas {
  z-index: 2;
  pointer-events: auto;
}

.actions {
  display: flex;
  justify-content: space-around;
}

.actions button {
  flex: 1;
  margin: 0 10rpx;
}
```

```json
{
  "component": true,
  "usingComponents": {}
}
```

### æ­¥éª¤2: æ™ºèƒ½é€‰æ‹©å·¥å…·

#### 2.1 æ™ºèƒ½é€‰æ‹©åŠŸèƒ½
```javascript
// utils/intelligent-selection.js

// åŸºäºé¢œè‰²ç›¸ä¼¼åº¦çš„æ™ºèƒ½é€‰æ‹©
const colorBasedSelection = (imageData, startX, startY, tolerance = 30) => {
  const width = imageData.width
  const height = imageData.height
  const data = imageData.data
  
  // è·å–èµ·å§‹ç‚¹çš„é¢œè‰²
  const startIndex = (startY * width + startX) * 4
  const startR = data[startIndex]
  const startG = data[startIndex + 1]
  const startB = data[startIndex + 2]
  
  // å­˜å‚¨å·²è®¿é—®çš„åƒç´ 
  const visited = new Set()
  const selected = new Set()
  const queue = [{ x: startX, y: startY }]
  
  while (queue.length > 0) {
    const { x, y } = queue.shift()
    const key = `${x},${y}`
    
    if (visited.has(key) || x < 0 || x >= width || y < 0 || y >= height) {
      continue
    }
    
    visited.add(key)
    
    // è·å–å½“å‰åƒç´ é¢œè‰²
    const index = (y * width + x) * 4
    const r = data[index]
    const g = data[index + 1]
    const b = data[index + 2]
    
    // è®¡ç®—é¢œè‰²å·®å¼‚
    const colorDiff = Math.sqrt(
      Math.pow(r - startR, 2) +
      Math.pow(g - startG, 2) +
      Math.pow(b - startB, 2)
    )
    
    if (colorDiff <= tolerance) {
      selected.add(key)
      
      // æ·»åŠ ç›¸é‚»åƒç´ åˆ°é˜Ÿåˆ—
      queue.push(
        { x: x - 1, y },
        { x: x + 1, y },
        { x, y: y - 1 },
        { x, y: y + 1 }
      )
    }
  }
  
  return selected
}

// ç”Ÿæˆé€‰æ‹©åŒºåŸŸçš„è’™ç‰ˆ
const generateSelectionMask = (selectedPixels, width, height) => {
  const maskData = new Uint8ClampedArray(width * height * 4)
  
  selectedPixels.forEach(key => {
    const [x, y] = key.split(',').map(Number)
    const index = (y * width + x) * 4
    
    maskData[index] = 255     // R
    maskData[index + 1] = 0   // G
    maskData[index + 2] = 0   // B
    maskData[index + 3] = 128 // A (åŠé€æ˜)
  })
  
  return new ImageData(maskData, width, height)
}

module.exports = {
  colorBasedSelection,
  generateSelectionMask
}
```

### æ­¥éª¤3: è’™ç‰ˆç¼–è¾‘é¡µé¢

#### 3.1 è’™ç‰ˆç¼–è¾‘é¡µé¢å®ç°
```xml
<!-- pages/mask-editor/mask-editor.wxml -->
<view class="mask-editor-page">
  <view class="header">
    <text class="title">æ ‡è®°ä¿®å¤åŒºåŸŸ</text>
    <text class="subtitle">åœ¨éœ€è¦ä¿®å¤çš„åŒºåŸŸä¸Šç»˜åˆ¶è’™ç‰ˆ</text>
  </view>
  
  <mask-editor 
    image-url="{{imageUrl}}"
    bind:mask-confirm="onMaskConfirm"
  />
  
  <!-- å¸®åŠ©æç¤º -->
  <view class="help-tips" wx:if="{{showTips}}">
    <view class="tip-item">
      <text class="tip-icon">âœï¸</text>
      <text class="tip-text">ä½¿ç”¨ç”»ç¬”æ ‡è®°éœ€è¦ä¿®å¤çš„åŒºåŸŸ</text>
    </view>
    <view class="tip-item">
      <text class="tip-icon">ğŸ§½</text>
      <text class="tip-text">ä½¿ç”¨æ©¡çš®æ“¦ä¿®æ­£æ ‡è®°åŒºåŸŸ</text>
    </view>
    <view class="tip-item">
      <text class="tip-icon">ğŸ‘†</text>
      <text class="tip-text">è°ƒæ•´ç”»ç¬”å¤§å°ä»¥è·å¾—æ›´ç²¾ç¡®çš„æ ‡è®°</text>
    </view>
  </view>
</view>
```

```javascript
// pages/mask-editor/mask-editor.js
Page({
  data: {
    imageUrl: '',
    showTips: true
  },

  onLoad(options) {
    if (options.imageUrl) {
      this.setData({
        imageUrl: decodeURIComponent(options.imageUrl)
      })
    } else {
      wx.showToast({
        title: 'æœªæ‰¾åˆ°å›¾ç‰‡',
        icon: 'none'
      })
      
      setTimeout(() => {
        wx.navigateBack()
      }, 1500)
    }
    
    // 3ç§’åéšè—æç¤º
    setTimeout(() => {
      this.setData({ showTips: false })
    }, 3000)
  },

  // è’™ç‰ˆç¡®è®¤
  onMaskConfirm(event) {
    const { detail } = event
    
    // ä¿å­˜è’™ç‰ˆæ•°æ®
    wx.setStorageSync('maskData', detail)
    
    // è·³è½¬åˆ°å¤„ç†é¡µé¢
    wx.navigateTo({
      url: `/pages/process/process?imageUrl=${encodeURIComponent(this.data.imageUrl)}`
    })
  }
})
```

```json
{
  "usingComponents": {
    "mask-editor": "/components/mask-editor/index"
  },
  "navigationBarTitleText": "ç»˜åˆ¶è’™ç‰ˆ"
}
```

### æ­¥éª¤4: è’™ç‰ˆå¤„ç†å·¥å…·

#### 4.1 è’™ç‰ˆæ•°æ®å¤„ç†
```javascript
// utils/mask-processing.js

// è’™ç‰ˆæ•°æ®è½¬æ¢
const convertMaskToProcessingFormat = (maskData, imageInfo) => {
  const { maskImagePath, strokes } = maskData
  const { width, height, offsetX, offsetY, scale } = imageInfo
  
  return {
    mask_image: maskImagePath,
    mask_strokes: strokes.map(stroke => ({
      tool: stroke.tool,
      size: stroke.size,
      points: stroke.points.map(point => ({
        x: (point.x - offsetX) / scale,
        y: (point.y - offsetY) / scale
      }))
    })),
    image_width: width / scale,
    image_height: height / scale
  }
}

// ä¼˜åŒ–è’™ç‰ˆè¾¹ç¼˜
const optimizeMaskEdges = (canvas, ctx) => {
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
  const data = imageData.data
  
  // åº”ç”¨é«˜æ–¯æ¨¡ç³Šæ¥è½¯åŒ–è¾¹ç¼˜
  const blurRadius = 2
  const blurredData = applyGaussianBlur(data, canvas.width, canvas.height, blurRadius)
  
  // åˆ›å»ºæ–°çš„å›¾åƒæ•°æ®
  const optimizedImageData = new ImageData(blurredData, canvas.width, canvas.height)
  ctx.putImageData(optimizedImageData, 0, 0)
  
  return optimizedImageData
}

// é«˜æ–¯æ¨¡ç³Šç®—æ³•
const applyGaussianBlur = (data, width, height, radius) => {
  const output = new Uint8ClampedArray(data.length)
  const kernel = generateGaussianKernel(radius)
  const kernelSize = kernel.length
  const half = Math.floor(kernelSize / 2)
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let r = 0, g = 0, b = 0, a = 0, weightSum = 0
      
      for (let ky = -half; ky <= half; ky++) {
        for (let kx = -half; kx <= half; kx++) {
          const py = y + ky
          const px = x + kx
          
          if (px >= 0 && px < width && py >= 0 && py < height) {
            const weight = kernel[ky + half] * kernel[kx + half]
            const index = (py * width + px) * 4
            
            r += data[index] * weight
            g += data[index + 1] * weight
            b += data[index + 2] * weight
            a += data[index + 3] * weight
            weightSum += weight
          }
        }
      }
      
      const outputIndex = (y * width + x) * 4
      output[outputIndex] = r / weightSum
      output[outputIndex + 1] = g / weightSum
      output[outputIndex + 2] = b / weightSum
      output[outputIndex + 3] = a / weightSum
    }
  }
  
  return output
}

// ç”Ÿæˆé«˜æ–¯æ ¸
const generateGaussianKernel = (radius) => {
  const size = radius * 2 + 1
  const kernel = new Array(size)
  const sigma = radius / 3
  const norm = 1 / (Math.sqrt(2 * Math.PI) * sigma)
  
  for (let i = 0; i < size; i++) {
    const x = i - radius
    kernel[i] = norm * Math.exp(-0.5 * (x / sigma) ** 2)
  }
  
  return kernel
}

// éªŒè¯è’™ç‰ˆæœ‰æ•ˆæ€§
const validateMask = (maskData) => {
  if (!maskData || !maskData.strokes) {
    return { valid: false, message: 'è’™ç‰ˆæ•°æ®æ— æ•ˆ' }
  }
  
  if (maskData.strokes.length === 0) {
    return { valid: false, message: 'è¯·å…ˆç»˜åˆ¶è’™ç‰ˆ' }
  }
  
  // æ£€æŸ¥è’™ç‰ˆåŒºåŸŸå¤§å°
  const totalPoints = maskData.strokes.reduce((sum, stroke) => sum + stroke.points.length, 0)
  if (totalPoints < 10) {
    return { valid: false, message: 'è’™ç‰ˆåŒºåŸŸå¤ªå°' }
  }
  
  return { valid: true }
}

module.exports = {
  convertMaskToProcessingFormat,
  optimizeMaskEdges,
  validateMask
}
```

## éªŒæ”¶æ ‡å‡†

### ç»˜åˆ¶åŠŸèƒ½éªŒæ”¶
- [ ] ç”»ç¬”å·¥å…·æ­£å¸¸å·¥ä½œ
- [ ] æ©¡çš®æ“¦å·¥å…·æ­£ç¡®æ“¦é™¤
- [ ] ç”»ç¬”å¤§å°è°ƒèŠ‚æœ‰æ•ˆ
- [ ] æ’¤é”€åŠŸèƒ½æ­£å¸¸å·¥ä½œ

### äº¤äº’ä½“éªŒéªŒæ”¶
- [ ] è§¦æ‘¸å“åº”çµæ•
- [ ] ç»˜åˆ¶æµç•…æ— å¡é¡¿
- [ ] å·¥å…·åˆ‡æ¢å¿«é€Ÿ
- [ ] æ“ä½œæç¤ºæ¸…æ™°

### è’™ç‰ˆè´¨é‡éªŒæ”¶
- [ ] è’™ç‰ˆè¾¹ç¼˜å¹³æ»‘
- [ ] é¢œè‰²å¯¹æ¯”åº¦åˆé€‚
- [ ] å¯¼å‡ºæ•°æ®å®Œæ•´
- [ ] åæ ‡è½¬æ¢å‡†ç¡®

### æ€§èƒ½éªŒæ”¶
- [ ] å†…å­˜å ç”¨åˆç†
- [ ] ç»˜åˆ¶æ€§èƒ½è‰¯å¥½
- [ ] å¤§å›¾ç‰‡å¤„ç†æ­£å¸¸
- [ ] å¤šæ¬¡æ“ä½œæ— å†…å­˜æ³„æ¼

## æ—¶é—´ä¼°ç®—

- **æ€»é¢„ä¼°æ—¶é—´**: 3-4å¤©
- **Canvasç»˜åˆ¶ç»„ä»¶**: 2å¤©
- **æ™ºèƒ½é€‰æ‹©å·¥å…·**: 1å¤©
- **é¡µé¢é›†æˆå’Œä¼˜åŒ–**: 1å¤©

## ä¾èµ–ä»»åŠ¡

- **å‰ç½®ä»»åŠ¡**: ä»»åŠ¡06 (å›¾åƒä¸Šä¼ åŠŸèƒ½å¼€å‘)
- **åç»­ä»»åŠ¡**: ä»»åŠ¡08 (AIå›¾åƒä¿®å¤åŠŸèƒ½é›†æˆ)

## é£é™©ç‚¹

### æŠ€æœ¯é£é™©
- Canvas 2D APIå…¼å®¹æ€§é—®é¢˜
- è§¦æ‘¸äº‹ä»¶ç²¾åº¦å’Œæ€§èƒ½
- å¤§å›¾ç‰‡å¤„ç†çš„å†…å­˜ç®¡ç†

### è§£å†³æ–¹æ¡ˆ
- æ·»åŠ Canvas 2Dé™çº§æ–¹æ¡ˆ
- ä¼˜åŒ–ç»˜åˆ¶ç®—æ³•å’Œäº‹ä»¶å¤„ç†
- å®ç°å›¾ç‰‡ç¼©æ”¾å’Œåˆ†å—å¤„ç†

## å‚è€ƒèµ„æ–™

- [å¾®ä¿¡å°ç¨‹åºCanvas 2D API](https://developers.weixin.qq.com/miniprogram/dev/api/canvas/Canvas.html)
- [è§¦æ‘¸äº‹ä»¶å¤„ç†](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)
- [å›¾åƒå¤„ç†æœ€ä½³å®è·µ](https://developers.weixin.qq.com/community/develop/article/doc/000c4ee0c2c2c09c5c8a3ef5251c13) 
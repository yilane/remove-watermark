# 任务02: 后端用户认证系统开发

## 任务概述

基于现有FastAPI框架，开发用户认证系统，支持微信小程序登录、JWT Token管理、用户权限控制等功能。

## 技术要求

### 核心技术栈
- **FastAPI**: Web框架
- **SQLAlchemy**: ORM框架
- **JWT**: JSON Web Token认证
- **bcrypt**: 密码加密
- **Redis**: 会话存储和缓存
- **python-jose**: JWT处理库

### 微信接口对接
- **微信登录API**: 获取用户OpenID
- **用户信息API**: 获取用户基本信息
- **小程序码API**: 生成分享码

## 实现步骤

### 步骤1: 数据库模型设计

#### 1.1 用户表设计
```python
# iopaint/database/models.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.sql import func

Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    openid = Column(String(255), unique=True, nullable=False, index=True)
    union_id = Column(String(255), nullable=True, index=True)
    nickname = Column(String(100), nullable=True)
    avatar_url = Column(String(500), nullable=True)
    phone = Column(String(20), nullable=True)
    email = Column(String(100), nullable=True)
    is_active = Column(Boolean, default=True)
    is_premium = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    last_login_at = Column(DateTime(timezone=True), nullable=True)
    login_count = Column(Integer, default=0)
    
class ProcessRecord(Base):
    __tablename__ = "process_records"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)
    original_image_url = Column(String(500), nullable=False)
    result_image_url = Column(String(500), nullable=True)
    mask_data = Column(Text, nullable=True)
    model_name = Column(String(50), nullable=False)
    status = Column(String(20), default="pending")  # pending, processing, completed, failed
    error_message = Column(Text, nullable=True)
    processing_time = Column(Integer, nullable=True)  # 处理时间(秒)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    completed_at = Column(DateTime(timezone=True), nullable=True)
```

#### 1.2 数据库连接配置
```python
# iopaint/database/connection.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
import os

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./iopaint.db")

engine = create_engine(
    DATABASE_URL,
    echo=True if os.getenv("DEBUG") == "1" else False
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def create_tables():
    from .models import User, ProcessRecord
    Base.metadata.create_all(bind=engine)
```

### 步骤2: JWT认证实现

#### 2.1 JWT处理模块
```python
# iopaint/auth/jwt_handler.py
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
import os

SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key-here")
ALGORITHM = os.getenv("JWT_ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("JWT_EXPIRATION_TIME", "30"))

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            return None
        return user_id
    except JWTError:
        return None

def hash_password(password: str):
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str):
    return pwd_context.verify(plain_password, hashed_password)
```

#### 2.2 认证中间件
```python
# iopaint/auth/middleware.py
from fastapi import HTTPException, Depends, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from .jwt_handler import verify_token
from ..database.connection import get_db
from ..database.models import User

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    user_id = verify_token(credentials.credentials)
    if user_id is None:
        raise credentials_exception
    
    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise credentials_exception
    
    return user

async def get_current_active_user(current_user: User = Depends(get_current_user)):
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user
```

### 步骤3: 微信认证实现

#### 3.1 微信API客户端
```python
# iopaint/auth/wechat_auth.py
import requests
import json
import os
from typing import Optional, Dict

class WeChatAuthClient:
    def __init__(self):
        self.app_id = os.getenv("WECHAT_APP_ID")
        self.app_secret = os.getenv("WECHAT_APP_SECRET")
        self.base_url = "https://api.weixin.qq.com"
    
    async def code_to_session(self, code: str) -> Optional[Dict]:
        """
        通过临时登录凭证获取session_key和openid
        """
        url = f"{self.base_url}/sns/jscode2session"
        params = {
            "appid": self.app_id,
            "secret": self.app_secret,
            "js_code": code,
            "grant_type": "authorization_code"
        }
        
        try:
            response = requests.get(url, params=params)
            result = response.json()
            
            if "errcode" in result:
                return None
            
            return {
                "openid": result["openid"],
                "session_key": result["session_key"],
                "unionid": result.get("unionid")
            }
        except Exception as e:
            print(f"WeChat auth error: {e}")
            return None
    
    async def get_user_info(self, session_key: str, encrypted_data: str, iv: str) -> Optional[Dict]:
        """
        解密用户信息
        """
        # 这里需要实现AES解密逻辑
        # 由于涉及加密解密，建议使用cryptography库
        pass
    
    async def get_access_token(self) -> Optional[str]:
        """
        获取小程序全局唯一后台接口调用凭据
        """
        url = f"{self.base_url}/cgi-bin/token"
        params = {
            "grant_type": "client_credential",
            "appid": self.app_id,
            "secret": self.app_secret
        }
        
        try:
            response = requests.get(url, params=params)
            result = response.json()
            
            if "errcode" in result:
                return None
            
            return result["access_token"]
        except Exception as e:
            print(f"Get access token error: {e}")
            return None
```

### 步骤4: Pydantic模型定义

#### 4.1 用户相关模型
```python
# iopaint/schemas/user.py
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

class UserBase(BaseModel):
    nickname: Optional[str] = None
    avatar_url: Optional[str] = None
    phone: Optional[str] = None
    email: Optional[str] = None

class UserCreate(UserBase):
    openid: str
    union_id: Optional[str] = None

class UserUpdate(UserBase):
    pass

class UserResponse(UserBase):
    id: int
    openid: str
    is_active: bool
    is_premium: bool
    created_at: datetime
    last_login_at: Optional[datetime]
    login_count: int
    
    class Config:
        from_attributes = True

class LoginRequest(BaseModel):
    code: str
    encrypted_data: Optional[str] = None
    iv: Optional[str] = None

class LoginResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"
    user: UserResponse
    expires_in: int
```

#### 4.2 处理记录模型
```python
# iopaint/schemas/process_record.py
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

class ProcessRecordBase(BaseModel):
    original_image_url: str
    model_name: str
    mask_data: Optional[str] = None

class ProcessRecordCreate(ProcessRecordBase):
    user_id: int

class ProcessRecordUpdate(BaseModel):
    result_image_url: Optional[str] = None
    status: Optional[str] = None
    error_message: Optional[str] = None
    processing_time: Optional[int] = None
    completed_at: Optional[datetime] = None

class ProcessRecordResponse(ProcessRecordBase):
    id: int
    user_id: int
    result_image_url: Optional[str]
    status: str
    error_message: Optional[str]
    processing_time: Optional[int]
    created_at: datetime
    completed_at: Optional[datetime]
    
    class Config:
        from_attributes = True
```

### 步骤5: API路由实现

#### 5.1 认证相关API
```python
# iopaint/miniprogram_api/auth_router.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import timedelta

from ..database.connection import get_db
from ..database.models import User
from ..schemas.user import LoginRequest, LoginResponse, UserResponse
from ..auth.wechat_auth import WeChatAuthClient
from ..auth.jwt_handler import create_access_token, ACCESS_TOKEN_EXPIRE_MINUTES

router = APIRouter(prefix="/api/v1/auth", tags=["认证"])
wechat_client = WeChatAuthClient()

@router.post("/wechat-login", response_model=LoginResponse)
async def wechat_login(
    login_data: LoginRequest,
    db: Session = Depends(get_db)
):
    # 验证微信登录凭证
    session_info = await wechat_client.code_to_session(login_data.code)
    if not session_info:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid WeChat login code"
        )
    
    openid = session_info["openid"]
    
    # 查找或创建用户
    user = db.query(User).filter(User.openid == openid).first()
    if not user:
        user = User(
            openid=openid,
            union_id=session_info.get("unionid"),
            login_count=1
        )
        db.add(user)
    else:
        user.login_count += 1
        user.last_login_at = datetime.utcnow()
    
    db.commit()
    db.refresh(user)
    
    # 生成JWT Token
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": str(user.id)},
        expires_delta=access_token_expires
    )
    
    return LoginResponse(
        access_token=access_token,
        user=UserResponse.from_orm(user),
        expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )

@router.post("/refresh", response_model=LoginResponse)
async def refresh_token(
    current_user: User = Depends(get_current_active_user)
):
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": str(current_user.id)},
        expires_delta=access_token_expires
    )
    
    return LoginResponse(
        access_token=access_token,
        user=UserResponse.from_orm(current_user),
        expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )

@router.get("/me", response_model=UserResponse)
async def get_current_user_info(
    current_user: User = Depends(get_current_active_user)
):
    return UserResponse.from_orm(current_user)
```

### 步骤6: 集成到主应用

#### 6.1 更新主应用配置
```python
# iopaint/api.py (扩展现有文件)
from fastapi import FastAPI
from .miniprogram_api.auth_router import router as auth_router
from .database.connection import create_tables

# 在现有FastAPI app基础上添加
app.include_router(auth_router)

# 在应用启动时创建数据库表
@app.on_event("startup")
async def startup_event():
    create_tables()
```

## 验收标准

### 功能验收
- [ ] 微信登录API正常工作
- [ ] JWT Token生成和验证正确
- [ ] 用户信息正确存储到数据库
- [ ] Token刷新功能正常
- [ ] 用户认证中间件正常拦截请求
- [ ] 数据库模型创建成功

### 安全验收
- [ ] JWT Token有效期控制正确
- [ ] 敏感信息不泄露到日志
- [ ] 数据库连接安全
- [ ] API输入验证完整
- [ ] 错误信息不暴露系统内部信息

### 性能验收
- [ ] 登录接口响应时间 < 500ms
- [ ] 数据库查询优化
- [ ] Redis缓存正常工作
- [ ] 并发登录测试通过

## 时间估算

- **总预估时间**: 4-5天
- **数据库设计和模型**: 1天
- **JWT认证实现**: 1天
- **微信API对接**: 1-2天
- **API开发和测试**: 1天

## 依赖任务

- 任务01: 开发环境搭建

## 风险点

1. **微信API变更**: 微信官方API可能发生变化
2. **安全漏洞**: JWT实现可能存在安全问题
3. **性能问题**: 大量用户同时登录的性能压力
4. **数据迁移**: 现有数据库结构与新设计的兼容性

## 解决方案

1. **API版本管理**: 关注微信官方文档更新
2. **安全测试**: 进行专门的安全测试
3. **性能优化**: 使用Redis缓存和数据库连接池
4. **渐进迁移**: 设计兼容的数据库迁移方案

## 参考资料

- [微信小程序登录文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html)
- [FastAPI认证文档](https://fastapi.tiangolo.com/tutorial/security/)
- [JWT.io官方文档](https://jwt.io/)
- [SQLAlchemy官方文档](https://docs.sqlalchemy.org/)

## 完成标志

认证系统完成后，应该能够：
1. 小程序端成功调用登录接口获取Token
2. 使用Token访问需要认证的API接口
3. Token过期后能够成功刷新
4. 用户信息正确存储和查询
5. 通过Postman测试所有认证相关接口 